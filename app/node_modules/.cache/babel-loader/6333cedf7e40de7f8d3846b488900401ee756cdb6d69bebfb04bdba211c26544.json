{"ast":null,"code":"var _jsxFileName = \"/home/dante/Escritorio/GitHub/Taller II/backoffice-web/app/src/controllers/Profile.js\";\nimport React, { Component } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport class Profile extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      userData: {}\n    };\n    this.handleApiResponse = this.handleApiResponse.bind(this);\n  }\n  componentDidMount() {\n    this.getUserData();\n  }\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Perfil del usuario\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 22,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Email: \", this.state.userData['first_name']]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 23,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Nombre: \", this.state.userData['last_name']]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 24,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Apellido: \", this.state.userData['email']]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 25,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 21,\n      columnNumber: 13\n    }, this);\n  }\n  handleApiResponse(userJson) {\n    this.setState({\n      userData: userJson.data\n    });\n  }\n\n  /* fetch devuelve una Promise, que en caso de que se resuelva correctamente el resultado va a ser un objeto Response */\n  /* fetch falla (lo atrapamos con el catch en lugar de con el then) solo si no se pudo completar la request o si hubo una falla en la red. No ante 400 o 500 */\n\n  getUserData() {\n    fetch(\"https://reqres.in/api/users/2\").then(response => response.json()).then(this.handleApiResponse);\n  }\n\n  /* Usar async await es básicamente sintax sugar. Hace parecer que los pedidos son sincrónicos. La ejecución de\n  \"pausa\" en la línea del await pero sin bloquear el hilo principal. Se reanuda cuando la promesa fue resuelta.\n  Es más simple de entender cuando tengo muchas llamadas asincrónicas dependientes una de otras. */\n\n  /*async getUserData() {\n      const response = await fetch(\"https://reqres.in/api/users/2\");\n      const jsonResponse = await response.json();\n      this.handleApiResponse(jsonResponse);\n  }*/\n}","map":{"version":3,"names":["React","Component","jsxDEV","_jsxDEV","Profile","constructor","props","state","userData","handleApiResponse","bind","componentDidMount","getUserData","render","children","fileName","_jsxFileName","lineNumber","columnNumber","userJson","setState","data","fetch","then","response","json"],"sources":["/home/dante/Escritorio/GitHub/Taller II/backoffice-web/app/src/controllers/Profile.js"],"sourcesContent":["import React, {Component} from 'react';\n\n\nexport class Profile extends Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            userData: {}\n        };\n\n        this.handleApiResponse = this.handleApiResponse.bind(this);\n    }\n\n    componentDidMount() {\n        this.getUserData();\n    }\n\n    render() {\n        return (\n            <div>\n                <h2>Perfil del usuario</h2>\n                <p>Email: {this.state.userData['first_name']}</p>\n                <p>Nombre: {this.state.userData['last_name']}</p>\n                <p>Apellido: {this.state.userData['email']}</p>\n            </div>\n        )\n    }\n\n    handleApiResponse(userJson) {\n        this.setState({userData: userJson.data})\n    }\n\n    /* fetch devuelve una Promise, que en caso de que se resuelva correctamente el resultado va a ser un objeto Response */\n    /* fetch falla (lo atrapamos con el catch en lugar de con el then) solo si no se pudo completar la request o si hubo una falla en la red. No ante 400 o 500 */\n\n    getUserData() {\n        fetch(\"https://reqres.in/api/users/2\").then(response => response.json()).then(this.handleApiResponse);\n    }\n\n\n    /* Usar async await es básicamente sintax sugar. Hace parecer que los pedidos son sincrónicos. La ejecución de\n    \"pausa\" en la línea del await pero sin bloquear el hilo principal. Se reanuda cuando la promesa fue resuelta.\n    Es más simple de entender cuando tengo muchas llamadas asincrónicas dependientes una de otras. */\n\n    /*async getUserData() {\n        const response = await fetch(\"https://reqres.in/api/users/2\");\n        const jsonResponse = await response.json();\n        this.handleApiResponse(jsonResponse);\n    }*/\n}"],"mappings":";AAAA,OAAOA,KAAK,IAAGC,SAAS,QAAO,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAGvC,OAAO,MAAMC,OAAO,SAASH,SAAS,CAAC;EACnCI,WAAWA,CAACC,KAAK,EAAE;IACf,KAAK,CAACA,KAAK,CAAC;IAEZ,IAAI,CAACC,KAAK,GAAG;MACTC,QAAQ,EAAE,CAAC;IACf,CAAC;IAED,IAAI,CAACC,iBAAiB,GAAG,IAAI,CAACA,iBAAiB,CAACC,IAAI,CAAC,IAAI,CAAC;EAC9D;EAEAC,iBAAiBA,CAAA,EAAG;IAChB,IAAI,CAACC,WAAW,EAAE;EACtB;EAEAC,MAAMA,CAAA,EAAG;IACL,oBACIV,OAAA;MAAAW,QAAA,gBACIX,OAAA;QAAAW,QAAA,EAAI;MAAkB;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,QAAK,eAC3Bf,OAAA;QAAAW,QAAA,GAAG,SAAO,EAAC,IAAI,CAACP,KAAK,CAACC,QAAQ,CAAC,YAAY,CAAC;MAAA;QAAAO,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,QAAK,eACjDf,OAAA;QAAAW,QAAA,GAAG,UAAQ,EAAC,IAAI,CAACP,KAAK,CAACC,QAAQ,CAAC,WAAW,CAAC;MAAA;QAAAO,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,QAAK,eACjDf,OAAA;QAAAW,QAAA,GAAG,YAAU,EAAC,IAAI,CAACP,KAAK,CAACC,QAAQ,CAAC,OAAO,CAAC;MAAA;QAAAO,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,QAAK;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,QAC7C;EAEd;EAEAT,iBAAiBA,CAACU,QAAQ,EAAE;IACxB,IAAI,CAACC,QAAQ,CAAC;MAACZ,QAAQ,EAAEW,QAAQ,CAACE;IAAI,CAAC,CAAC;EAC5C;;EAEA;EACA;;EAEAT,WAAWA,CAAA,EAAG;IACVU,KAAK,CAAC,+BAA+B,CAAC,CAACC,IAAI,CAACC,QAAQ,IAAIA,QAAQ,CAACC,IAAI,EAAE,CAAC,CAACF,IAAI,CAAC,IAAI,CAACd,iBAAiB,CAAC;EACzG;;EAGA;AACJ;AACA;;EAEI;AACJ;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}